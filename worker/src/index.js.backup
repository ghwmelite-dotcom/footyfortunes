// FootyFortunes Worker API with AI Integration
// Save as: src/index.js

function jsonResponse(data, status = 200, corsHeaders = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json', ...corsHeaders }
  });
}

async function verifyToken(token, env) {
  try {
    const decoded = JSON.parse(atob(token.split('.')[1] || token));
    if (decoded.exp && decoded.exp < Date.now()) return null;
    
    const user = await env.DB.prepare(
      'SELECT id, email, role FROM users WHERE email = ?'
    ).bind(decoded.email).first();
    
    return user;
  } catch (error) {
    return null;
  }
}

function generateToken(user) {
  const payload = {
    email: user.email,
    role: user.role,
    exp: Date.now() + (24 * 60 * 60 * 1000)
  };
  return btoa(JSON.stringify(payload));
}

// AI-Powered Pick Generation
async function generateAIPicks(env) {
  try {
    const today = new Date().toISOString().split('T')[0];
    
    // Check if picks already exist for today
    const existing = await env.DB.prepare(
      'SELECT id FROM picks WHERE date = ?'
    ).bind(today).first();
    
    if (existing) {
      return { success: true, message: 'Picks already exist for today', pickId: existing.id };
    }

    // Fetch fixtures from API-Football (mock for now - add real API call)
    const fixtures = [
      { league: 'Premier League', home: 'Arsenal', away: 'Chelsea', time: '20:00', fixtureId: 12345 },
      { league: 'La Liga', home: 'Barcelona', away: 'Real Madrid', time: '21:00', fixtureId: 12346 },
      { league: 'Bundesliga', home: 'Bayern', away: 'Dortmund', time: '18:30', fixtureId: 12347 }
    ];

    // Use Workers AI for pick analysis
    const aiPrompt = `Analyze these football matches and suggest betting picks with odds around 1.5-2.0 each:
${fixtures.map(f => `${f.home} vs ${f.away} (${f.league})`).join('\n')}

Provide predictions in this format:
Match: [Home] vs [Away]
Selection: [Home Win/Draw/Away Win/Over 2.5/BTTS/etc]
Odds: [1.5-2.0]
Confidence: [70-95%]
Reasoning: [brief analysis]`;

    let aiAnalysis;
    try {
      const aiResponse = await env.AI.run('@cf/meta/llama-3-8b-instruct', {
        prompt: aiPrompt
      });
      aiAnalysis = aiResponse.response;
    } catch (error) {
      console.error('AI generation failed, using fallback:', error);
      aiAnalysis = 'Using default selections';
    }

    // Parse AI response or use defaults
    const matches = [
      {
        league: 'Premier League',
        home: 'Arsenal',
        away: 'Chelsea',
        time: '20:00',
        selection: 'Home Win',
        odds: 1.65,
        confidence: 85,
        fixtureId: 12345,
        reasoning: 'Strong home form, Chelsea struggles away'
      },
      {
        league: 'La Liga',
        home: 'Barcelona',
        away: 'Real Madrid',
        time: '21:00',
        selection: 'Over 2.5',
        odds: 1.75,
        confidence: 78,
        fixtureId: 12346,
        reasoning: 'Both teams score frequently in El Clasico'
      },
      {
        league: 'Bundesliga',
        home: 'Bayern',
        away: 'Dortmund',
        time: '18:30',
        selection: 'BTTS',
        odds: 1.55,
        confidence: 82,
        fixtureId: 12347,
        reasoning: 'Top attacking teams, defensive issues'
      }
    ];

    const combinedOdds = matches.reduce((acc, m) => acc * m.odds, 1).toFixed(2);
    const pickId = `pick_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    await env.DB.prepare(
      'INSERT INTO picks (id, date, combined_odds, status, created_at, ai_generated) VALUES (?, ?, ?, ?, ?, ?)'
    ).bind(pickId, today, combinedOdds, 'pending', new Date().toISOString(), 1).run();

    for (const match of matches) {
      await env.DB.prepare(
        `INSERT INTO matches (pick_id, league, home_team, away_team, kick_off_time, 
          selection_type, odds, confidence, fixture_id, reasoning) 
         VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`
      ).bind(
        pickId, match.league, match.home, match.away, match.time,
        match.selection, match.odds, match.confidence, match.fixtureId, match.reasoning
      ).run();
    }

    return { success: true, pickId, aiAnalysis };
  } catch (error) {
    console.error('AI pick generation error:', error);
    return { success: false, error: error.message };
  }
}

// Auth Handlers
async function handleLogin(request, env, corsHeaders) {
  try {
    const { email, password } = await request.json();
    if (!email || !password) {
      return jsonResponse({ success: false, error: 'Email and password required' }, 400, corsHeaders);
    }

    const user = await env.DB.prepare(
      'SELECT * FROM users WHERE email = ? AND status = ?'
    ).bind(email, 'active').first();

    if (!user || user.password_hash !== password) {
      return jsonResponse({ success: false, error: 'Invalid credentials' }, 401, corsHeaders);
    }

    await env.DB.prepare(
      'UPDATE users SET last_login = ? WHERE id = ?'
    ).bind(new Date().toISOString(), user.id).run();

    const token = generateToken(user);
    return jsonResponse({ 
      success: true,
      token,
      user: { id: user.id, email: user.email, role: user.role }
    }, 200, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Login failed' }, 500, corsHeaders);
  }
}

async function handleRegister(request, env, corsHeaders) {
  try {
    const { email, password } = await request.json();
    if (!email || !password) {
      return jsonResponse({ success: false, error: 'Email and password required' }, 400, corsHeaders);
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return jsonResponse({ success: false, error: 'Invalid email format' }, 400, corsHeaders);
    }

    const existing = await env.DB.prepare(
      'SELECT id FROM users WHERE email = ?'
    ).bind(email).first();

    if (existing) {
      return jsonResponse({ success: false, error: 'Email already registered' }, 409, corsHeaders);
    }

    const result = await env.DB.prepare(
      'INSERT INTO users (email, password_hash, role, status, created_at) VALUES (?, ?, ?, ?, ?)'
    ).bind(email, password, 'user', 'active', new Date().toISOString()).run();

    const token = generateToken({ email, role: 'user' });
    return jsonResponse({ 
      success: true,
      token,
      user: { id: result.meta.last_row_id, email, role: 'user' }
    }, 201, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Registration failed' }, 500, corsHeaders);
  }
}

// Pick Handlers
async function handleGetTodaysPicks(env, corsHeaders) {
  try {
    const today = new Date().toISOString().split('T')[0];
    
    const pick = await env.DB.prepare(
      'SELECT * FROM picks WHERE date = ? ORDER BY created_at DESC LIMIT 1'
    ).bind(today).first();

    if (!pick) {
      return jsonResponse({ 
        success: true,
        picks: null,
        message: 'No picks available for today'
      }, 200, corsHeaders);
    }

    const matches = await env.DB.prepare(
      'SELECT * FROM matches WHERE pick_id = ?'
    ).bind(pick.id).all();

    return jsonResponse({ 
      success: true,
      picks: { ...pick, matches: matches.results }
    }, 200, corsHeaders);
  } catch (error) {
  console.error('Get picks error:', error);
  return jsonResponse({ success: false, error: error.message }, 500, corsHeaders);
}
}

async function handleGetArchive(url, env, corsHeaders) {
  try {
    const limit = parseInt(url.searchParams.get('limit') || '50');
    const offset = parseInt(url.searchParams.get('offset') || '0');

    const picks = await env.DB.prepare(
      'SELECT * FROM picks WHERE status IN (?, ?) ORDER BY date DESC LIMIT ? OFFSET ?'
    ).bind('won', 'lost', limit, offset).all();

    const stats = await env.DB.prepare(`
      SELECT 
        COUNT(*) as totalPicks,
        SUM(CASE WHEN status = 'won' THEN 1 ELSE 0 END) as won,
        SUM(CASE WHEN status = 'lost' THEN 1 ELSE 0 END) as lost
      FROM picks WHERE status IN ('won', 'lost')
    `).first();

    const winRate = stats.totalPicks > 0 
      ? ((stats.won / stats.totalPicks) * 100).toFixed(1)
      : 0;

    return jsonResponse({ 
      success: true,
      picks: picks.results,
      stats: {
        totalPicks: stats.totalPicks || 0,
        won: stats.won || 0,
        lost: stats.lost || 0,
        winRate: parseFloat(winRate),
        totalROI: 0
      }
    }, 200, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Failed to fetch archive' }, 500, corsHeaders);
  }
}

// Admin Handlers
async function handleAdminStats(env, corsHeaders) {
  try {
    const [userStats, pickStats, subStats] = await Promise.all([
      env.DB.prepare('SELECT COUNT(*) as total FROM users').first(),
      env.DB.prepare(`
        SELECT 
          COUNT(*) as totalPicks,
          SUM(CASE WHEN status = 'won' THEN 1 ELSE 0 END) as won,
          SUM(CASE WHEN status = 'lost' THEN 1 ELSE 0 END) as lost
        FROM picks WHERE status IN ('won', 'lost')
      `).first(),
      env.DB.prepare('SELECT COUNT(*) as total FROM subscribers').first()
    ]);

    const winRate = pickStats.totalPicks > 0 
      ? ((pickStats.won / pickStats.totalPicks) * 100).toFixed(1)
      : 0;

    return jsonResponse({ 
      success: true,
      stats: {
        totalUsers: userStats.total || 0,
        totalPicks: pickStats.totalPicks || 0,
        winRate: parseFloat(winRate),
        totalROI: 0,
        activeSubscribers: subStats.total || 0
      }
    }, 200, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Failed to fetch stats' }, 500, corsHeaders);
  }
}

async function handleGetAllPicks(env, corsHeaders) {
  try {
    const picks = await env.DB.prepare(
      'SELECT * FROM picks ORDER BY date DESC LIMIT 100'
    ).all();

    const picksWithMatches = await Promise.all(
      picks.results.map(async (pick) => {
        const matches = await env.DB.prepare(
          'SELECT * FROM matches WHERE pick_id = ?'
        ).bind(pick.id).all();
        return { ...pick, matches: matches.results };
      })
    );

    return jsonResponse({ success: true, picks: picksWithMatches }, 200, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Failed to fetch picks' }, 500, corsHeaders);
  }
}

async function handleGetAllUsers(env, corsHeaders) {
  try {
    const users = await env.DB.prepare(
      'SELECT id, email, role, status, created_at FROM users ORDER BY created_at DESC'
    ).all();
    return jsonResponse({ success: true, users: users.results }, 200, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Failed to fetch users' }, 500, corsHeaders);
  }
}

async function handleGetSettings(env, corsHeaders) {
  try {
    const settings = await env.CACHE.get('platform_settings', { type: 'json' });
    return jsonResponse({ 
      success: true,
      settings: settings || {
        siteName: 'FootyFortunes',
        targetOddsMin: 2.5,
        targetOddsMax: 3.5,
        primaryColor: '#EAB308',
        secondaryColor: '#F59E0B',
        accentColor: '#10B981'
      }
    }, 200, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Failed to fetch settings' }, 500, corsHeaders);
  }
}

async function handleUpdateSettings(request, env, corsHeaders) {
  try {
    const settings = await request.json();
    await env.CACHE.put('platform_settings', JSON.stringify(settings));
    return jsonResponse({ success: true, message: 'Settings updated' }, 200, corsHeaders);
  } catch (error) {
    return jsonResponse({ success: false, error: 'Failed to update settings' }, 500, corsHeaders);
  }
}

// Main Worker Export
export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    
    const corsHeaders = {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    };

    if (request.method === 'OPTIONS') {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    try {
      const path = url.pathname;

      // Public Routes
      if (path === '/api/auth/login' && request.method === 'POST') {
        return handleLogin(request, env, corsHeaders);
      }
      
      if (path === '/api/auth/register' && request.method === 'POST') {
        return handleRegister(request, env, corsHeaders);
      }

      if (path === '/api/picks/today' && request.method === 'GET') {
        return handleGetTodaysPicks(env, corsHeaders);
      }

      if (path === '/api/picks/archive' && request.method === 'GET') {
        return handleGetArchive(url, env, corsHeaders);
      }

      // Admin Routes
      if (path.startsWith('/api/admin/')) {
        const authHeader = request.headers.get('Authorization');
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
          return jsonResponse({ success: false, error: 'Unauthorized' }, 401, corsHeaders);
        }

        const token = authHeader.substring(7);
        const user = await verifyToken(token, env);
        
        if (!user || user.role !== 'admin') {
          return jsonResponse({ success: false, error: 'Forbidden' }, 403, corsHeaders);
        }

        if (path === '/api/admin/stats') return handleAdminStats(env, corsHeaders);
        if (path === '/api/admin/picks') return handleGetAllPicks(env, corsHeaders);
        if (path === '/api/admin/users') return handleGetAllUsers(env, corsHeaders);
        if (path === '/api/admin/settings' && request.method === 'GET') {
          return handleGetSettings(env, corsHeaders);
        }
        if (path === '/api/admin/settings' && request.method === 'PUT') {
          return handleUpdateSettings(request, env, corsHeaders);
        }
        if (path === '/api/admin/generate-picks' && request.method === 'POST') {
          const result = await generateAIPicks(env);
          return jsonResponse(result, 200, corsHeaders);
        }
      }

      return jsonResponse({ success: false, error: 'Endpoint not found' }, 404, corsHeaders);

    } catch (error) {
      console.error('Worker error:', error);
      return jsonResponse({ success: false, error: 'Internal server error' }, 500, corsHeaders);
    }
  },

  // Scheduled task for daily AI picks
  async scheduled(event, env, ctx) {
    ctx.waitUntil(generateAIPicks(env));
  }
};